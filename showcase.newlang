// Don't be fooled by what's below! Though it has the conciseness of Python, it has the performance of Rust and C++! The language was designed to have zero-cost abstractions everywhere; everything is done at compile-time except your logic.
// Memory is managed through the use of several tricks and techniques that the compiler employs, invisible to the end user: namely, a borrowing/ownership system and manual memory management where necessary.

// the language supports multiple paradigms, including:
// -- OOP
// -- Generic Programming
// -- Functional Programming
// -- Meta-programming
// -- Procedural Programming

// The language was built with one philosophy: nothing is hardcoded. Everything in the language and standard library should be able to be implemented by users.
// However, the language should be recognizable across codebases. Ergo, you can only customize the language so much; otherwise, you should not be able to recognize it from project-to-project.

// CHAPTER 1: THE BASICS
x = 5 // assign variable x to the value 5

foo = { // create a function named 'foo' with no parameters
    print("Hello, from foo!") // call the print function with a string
}

num = input() // input is a function that returns a string
num = parseInt(num) // shadow the variable 'num' and make it an int with the previous value of 'num'

bar = num: int {
    return num * num
}

// Even though we did not define the above functions, they are included in the prelude.

// CHAPTER 2: PRESENCE

// Presence is an all-encompassing term for optional values and errors.

may_make_error = num: int {
    if num == 10 {
        throw "This number cannot be 10!"
    }
    return 10 * 10
}

newNum = may_make_error(3)

if newNum {
    print(newNum) // prints 9; we can access the variable (and its properties/methods, if any) when we know it exists,
    print("always true")
}

// The same presence model is applied for errors and values that may not exist; for this reason, a function, if returning something, does not need to have return paths for every control flow; the presence model is applied implicitly.
// Something note-worthy is that functions, if it is guranteed that a return value exists as their output, one will not have to check for presence; it will always be true.
// in the above example, for example, since everything is done statically, the compiler warns us that the value will always exist.

newNum = may_make_error(10) // shadow the variable newNum

if newNum {

} else {
    // if an error was thrown, we can use a variable called error.
    print(error)
    // otherwise, if a variable just doesn't exist, you don't get information, as none would be of use.
}

// whether a value exists is only checked when it is used. this means that it can be implicitly passed to functions,
// but regardless, wherever it is used, it must be handled.

// CHAPTER 3: STRUCTS, TRAITS, CLASSES

// First, let's define the difference between a 'class' and a 'struct'.
// A class can extend other classes, allowing for OOP (Object-Oriented Programming).
// A struct is data (similar to fields in a class) that can have 'traits' attached to it.
// A trait is composed of functions that must be implemented by the struct it is applied to.
// Classes can only extend other classes, and vice-versa for structs.

class Entity { // think of this class as an interface, with only declared methods; since not all methods are implemented, it cannot be instantiated
    get_id = {}: int // here, we have to explicitly type the return type of the method; if we didn't, it would have been a void

    set_id = {} // this is a void method
}

class Person : Entity {
    id: int
    name: string
    age: int

    get_name = {
        return self.name // self is implicitly brought into scope in methods in a class
    }

    set_name = name: string {
        self.name = name
    }

    get_age = {
        return self.age
    }

    set_age = age: int {
        self.age = age
    }

    get_id = {
        return self.id
    }

    set_id = id: int {
        self.id = id
    }
}

class Employee : Person { // The : means 'Employee extends Person' in this case
    job: string

    get_job = {
        return self.job
    }

    set_job = job: string {
        self.job = job
    }
}

employee = Employee()

if employee : Person { // essentially checking 'is Employee a Person?' YES!
    if employee.get_job() {
        // this will never print, always false; we never set the employee's job!
        print(employee.get_job())
    }
}

trait Printable {
    print = {} // we declare that the implementing struct must include a function print.
}

struct Point : Printable {
    x: int
    y: int
    print = {
        print("{x: \{x}, y: \{y}}") // we support string interpolation with \{}!
    }
}

// Sometimes, however, implementing the same trait many times can be cumbersome. Traits can have default implementations.

trait Printable {
    print = {} // DECLARES the print function
    print = { // CREATES A DEFAULT IMPLEMENTATION of the print function that is used unless the user implements their own.
        str = "{"
        self.fields.forEach(field { // we don't have to specify the type of 'field'; we know what it is since it is a callback function
        if !field.value.getTrait("Printable") return;
            str += "\{field.name}: \{field.value}, " // the += operator is overloaded; more on that later
        })
        str.trim()
        str += "}"
    }
}

struct Auction : Printable {
    name: string
    price: double
    sellingLocation: Point
}

// To create a struct, you do it the same as a class, except for the fact that you must specify ALL fields in the struct
auction = Auction("Diamond Sword", 1000, Point(20, 98))

// Fields on classes can never be accessed directly; getters/setters must be written for mutable state. The opposite is true for structs.

// Summary:
// Use classes when you have mutable state, need inheritance, and do not know all values when instantiating the object.
// Use structs when you need immutability, need composition, and know all values when instantiating the object.